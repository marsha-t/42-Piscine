## ft_strlcat

|               ft_strlcat        |
|---------------------------------|
| Turn-in directory : ex05/       |
| Files to turn in : ft_strlcat.c |
| Allowed functions : None       |

- Reproduce the behavior of the function <code>strlcat</code> (<code>man strlcat</code>).
- Here's how it should be prototyped:
```
unsigned int ft_strlcat(char *dest, char *src, unsigned int size);
```

<details>
<summary><h3>Testing</h3></summary>

<pre><code>#include &ltstdio.h&gt
#include &ltstring.h&gt
int	main(void)
{
    unsigned int 	n; 
	char	src[11] = "5678901";
	char	dest1[30]= "1234";	
	char	dest2[30]= "1234";
	char	dest3[20] = "1234";
	char	dest4[20] = "1234";
	char	dest5[20] = "1234";
	char	dest6[20] = "1234";
	char	dest7[20] = "1234";
	char	dest8[20] = "1234";

	n = ft_strlcat(dest1, src, 6); 
	printf("ft_strlcat: src: %s, dest: %s, return value: %d\n", src, dest1, n);
	n = strlcat(dest2, src, 6);
	printf("strlcat:    src: %s, dest: %s, return value: %d\n", src, dest2, n);
	n = ft_strlcat(dest3, src, 3); 
	printf("ft_strlcat: src: %s, dest: %s, return value: %d\n", src, dest3, n);	
	n = strlcat(dest4, src, 3); 
	printf("strlcat:    src: %s, dest: %s, return value: %d\n", src, dest4, n);
	n = ft_strlcat(dest5, src, 0); 
	printf("ft_strlcat: src: %s, dest: %s, return value: %d\n", src, dest5, n);	
	n = strlcat(dest6, src, 0); 
	printf("strlcat:    src: %s, dest: %s, return value: %d\n", src, dest6, n);
	n = ft_strlcat(dest7, src, 30); 
	printf("ft_strlcat: src: %s, dest: %s, return value: %d\n", src, dest7, n);	
	n = strlcat(dest8, src, 30); 
	printf("strlcat:    src: %s, dest: %s, return value: %d\n", src, dest8, n);
	return (0);
}</code></pre>

Note that the last test case using <code>strlcat(dest8, src, 30)</code> results in an overflow error. The following output is generated by commenting out the following lines of code:

<pre><code>char	dest8[20] = "1234";
...
n = strlcat(dest8, src, 30); 
printf("strlcat:    src: %s, dest: %s, return value: %d\n", src, dest8, n); </code></pre>

See [testing file](main.c)

</details>

<details>
<summary><h3>Output</h3></summary>

<pre><code>ft_strlcat: src: 5678901, dest: 12345, return value: 11
strlcat:    src: 5678901, dest: 12345, return value: 11
ft_strlcat: src: 5678901, dest: 1234, return value: 10
strlcat:    src: 5678901, dest: 1234, return value: 10
ft_strlcat: src: 5678901, dest: 1234, return value: 7
strlcat:    src: 5678901, dest: 1234, return value: 7
ft_strlcat: src: 5678901, dest: 12345678901, return value: 11</code></pre>

</details>


<details>
<summary><h3>Approach</h3></summary>

<code>strlcat</code> is intended to be an improvement over <code>strcat</code> and <code>strncat</code>. Like <code>strlcpy</code>, <code>strlcat</code> guarantees that the result will be null-terminated. In <code>strlcat</code>, <code>size</code> refers to the total size of the concatenated string and not the number of characters to be copied over from <code>src</code>, and hence, strlcat will append <code>size - strlen(dest) - 1</code> characters from <code>src</code>. 

Broadly, <code>strlcat</code> returns the total length of the string to be created:
- When <code>size</code> is set 'resonably' (i.e., it is at least <code>strlen(dest)</code>), it returns <code>strlen(dest) + strlen(src)</code>
- However, when <code>size</code> is set below <code>strlen(dest)</code>, <code>strlcat</code> returns <code>size + strlen(src)</code>. This is not apparent from the manual and was deduced from experimentation with the <code>strlcat</code> function.

This <a href=ft_strstr.c>solution</a>:
- determines the lengths of <code>src</code> and <code>dest</code> (lines 30-31);
- decides which values to return by comparing the length of <code>dest</code> to <code>size</code> (lines 32-34);
- copies over characters from src to the end of dest (the number of characters is determined by size and the length of dest) (lines 35-41); 
- null-terminates dest (line 42); and
- returns the required value (line 43). 

Since it will be used multiple times, <code>ft_strlen</code> is reused from an <a href=../../c01/06_ft_strlen>earlier exercise</a>. It is then applied to <code>dest</code> and <code>str</code> to calculate their respective lengths (lines 30-31). <code>ft_strlen</code> can also be rejigged to return an <code>unsigned int</code> but it doesn't cause any issue here to have it return an <code>int</code>.

Next, we declare a <code>total</code> variable to hold the return value. By default, it returns the length of <code>dest</code> and <code>src</code> (line 32). However, when <code>size</code> is unreasonably set below the length of <code>dest</code>, we set <code>total</code> to <code>size</code> + length of <code>src</code> (lines 33-34).

In order to append to the end of <code>dest</code>, we use <code>dest_l</code> to index <code>dest</code> since the index of <code>dest_l</code> refers to the null terminator in <code>dest</code>. Meanwhile, <code>i</code> is used to index <code>src</code> in order to copy over characters from <code>src</code> to <code>dest</code> (line 38). As we loop through <code>src</code>, we will increment both <code>dest_l</code> and <code>i</code> (lines 39-40). The number of characters to be copied over is the excess of <code>size</code> over <code>dest_l</code>, accounting for 1 null terminator in <code>size</code>. This is determined with the <code>while</code> loop condition of <code>dest_l + 1 < size</code>. This is equivalent to <code>dest_l < size - 1</code>. Both works - it's a matter of what is more intuitive for you. 

The rest of the code is similar to <a href=../02_ft_strcat>ft_strcat</a> and <a href=../03_ft_strncat>ft_strncat</a>.

</details>